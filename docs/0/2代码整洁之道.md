---
prev: 1设计模式
next: 3认证授权
---
* [返回主页](../home.md)

## 代码整洁之道
### 简化条件表达式
#### 分解条件式
```markdown
有一个复杂的条件（if-then-else）语句，从if、then、else 三个段落中分别提炼出独立函数
```
```java{4,5}
//原代码
private ExtensionResult<Boolean> push(ExtensionParameter parameter, int needModel) {
    log.info("push parameter:{}，needModel:{}" + JSONObject.toJSONString(parameter), needModel);
    if (parameter == null || parameter.getParameters() == null
            || parameter.getParameters().length == 0 || parameter.getParameters().length <= 1) {
        log.info("parameter is null");
        return ExtensionResult.success(true);
    }
    ..................
    return ExtensionResult.success(true);
}
```
```java{12}
//改造后
private ExtensionResult<Boolean> push(ExtensionParameter parameter, int needModel) {
    log.info("push parameter:{}，needModel:{}" + JSONObject.toJSONString(parameter), needModel);
    if (isParameterInvalid(parameter)) {
    log.info("parameter is null");
    return ExtensionResult.success(true);
    }
    ..................
    return ExtensionResult.success(true);
    }

private boolean isParameterInvalid(final ExtensionParameter parameter) {
    return parameter == null || parameter.getParameters() == null
    || parameter.getParameters().length == 0 || parameter.getParameters().length <= 1;
}
```

#### 合并条件式
```markdown
有一系列条件测试，都得到相同结果。将这些测试合并为一个条件式，并将这个条件式提炼成为一个独立函数
```
```java{6,10}
//原代码
public List<JSONObject> getSubDeviceRoomRelationList(ApiRequestDO apiRequestDO) {
    String gwId = apiRequestDO.getGwId();
    ValidateUtils.validateBlankParam("gwId", gwId, true);
    GatewayCache gateway = deviceAdaptService.getByIdInCache(gwId);
    if (null == gateway) {
        logger.warn("gateway is not exist! {}", gwId);
        throw new TermNotExistsException(EuropaTermCode.DEVICE);
    }
    if (StringUtils.isBlank(gateway.getOwnerId())) {
        logger.warn("gateway ownerId is empty! {}", gwId);
        throw new TermNotExistsException(EuropaTermCode.DEVICE);
    }
    ...........
    return result;
}
```
```java{13}
//改造后
public List<JSONObject> getSubDeviceRoomRelationList(ApiRequestDO apiRequestDO) {
    String gwId = apiRequestDO.getGwId();
    ValidateUtils.validateBlankParam("gwId", gwId, true);
    GatewayCache gateway = deviceAdaptService.getByIdInCache(gwId);
    if (isTermNotExists(gateway)) {
        throw new TermNotExistsException(EuropaTermCode.DEVICE);
    }
    ...........
    return result;
}

private boolean isTermNotExists(final GatewayCache gateway) {
    return null == gateway || StringUtils.isBlank(gateway.getOwnerId());
}
```

#### 合并重复的条件片段
```markdown
在条件式的每个分支上有着相同的一段代码,将这段重复代码搬移到条件式之外。
```
```java
//原代码
if (isSpecialDeal()) {
    total = price * 0.95;
    send();
}else {
    total = price * 0.98;
    send();
}
```
```java
//改造后
if (isSpecialDeal())
    total = price * 0.95;
else
    total = price * 0.98;
send();
```
#### 以break 语句或return 的语句取代控制标记
```java
//原代码
void checkSecurity(String[] people) {
    String found = "";
    for (int i = 0; i < people.length; i++) {
        if (found.equals("")) {
            if (people[i].equals ("Don")){
                sendAlert();
                found = "Don";
            }
            if (people[i].equals ("John")){
                sendAlert();
                found = "John";
            }
        }
    }
    someLaterCode(found);
}
```
```java
//改造后
String foundMiscreant(String[] people){
    for (int i = 0; i < people.length; i++) {
        if (people[i].equals ("Don")){
            sendAlert();
            return "Don";
        }
        if (people[i].equals ("John")){
            sendAlert();
            return "John";
        }
    }
    return "";
}
```

#### 以卫语句取代嵌套条件式
```java
//原代码
@Override
public Boolean deleteHolidayTimers(String resId, Integer resType, String category, String uid, String timeZoneId) {
    ..........
    if (Objects.nonNull(holidayTimersVO)) {
        boolean flag = TimerUtils.rightNowExecuteOrNot(holidayTimersVO.getStartDate(),
        holidayTimersVO.getEndDate(), holidayTimersVO.getStartTime(), holidayTimersVO.getEndTime(), timeZoneId);
        log.info("BaseTimerService deleteHolidayTimers flag = {},checkInPauseManual = {},holidayTimersVO = {}",
        flag, wkfUtilService.checkInPauseManual(resId, resType), JSONObject.toJSONString(holidayTimersVO));
        if (flag && !wkfUtilService.checkInPauseManual(resId, resType)) {
            //开始执行假期的时候，要把点击在家/离家标记清除
            String temKey = String.format(Constant.TEMP_PERIOD_KV_KEY, resId);
            businessStorageAdaptService.storeWkfKV(temKey, "", true);
            dpIssueFactory.matchIssueDpByWorkMode(WorkModeEnum.CLEAR_LAST_CLICK.getWorkMode()).doIssueDp(resId, resType);
            if (!wkfUtilService.checkExistWeekTimers(resId, resType)) {
                // 如果不存在周定时 下发手动模式
                dpIssueFactory.matchIssueDpByWorkMode(WorkModeEnum.MANUAL.getWorkMode()).doIssueDp(resId, resType);
            } else {
                // 如果存在周定时 就还按照原来的逻辑下发指令
                // 判断是否是正在执行的假期：如果是正在执行的假期则下发（取消假期后的模式：重新下发温度 周定时温度 > 离家温度），否则则不下发
                issueWeekDp(resId, resType, timeZoneId, TimerUtils.getTodayLoops(timeZoneId));
            }
        }
    }
    return true;
}
```
```java
//改造后
@Override
public Boolean deleteHolidayTimers(String resId, Integer resType, String category, String uid, String timeZoneId) {
    ..........
    if (isNotInVacation(holidayTimersVO)) return true;
    
    String temKey = String.format(Constant.TEMP_PERIOD_KV_KEY, resId);
    businessStorageAdaptService.storeWkfKV(temKey, "", true);
    dpIssueFactory.matchIssueDpByWorkMode(WorkModeEnum.CLEAR_LAST_CLICK.getWorkMode()).doIssueDp(resId, resType);
    if (!wkfUtilService.checkExistWeekTimers(resId, resType)) {
        // 如果不存在周定时 下发手动模式
        dpIssueFactory.matchIssueDpByWorkMode(WorkModeEnum.MANUAL.getWorkMode()).doIssueDp(resId, resType);
        return true;
    }
    
    // 如果存在周定时 就还按照原来的逻辑下发指令
    issueWeekDp(resId, resType, timeZoneId, TimerUtils.getTodayLoops(timeZoneId));
    return true;
}

private boolean isNotInVacation(final Object holidayTimersVO) {
    if (Objects.isNull(holidayTimersVO)) return true;
    boolean flag = TimerUtils.rightNowExecuteOrNot(holidayTimersVO.getStartDate(), holidayTimersVO.getEndDate(),
    holidayTimersVO.getStartTime(), holidayTimersVO.getEndTime(), timeZoneId);
    return !flag || wkfUtilService.checkInPauseManual(resId, resType);
}
```

#### 以多态取代条件表达式
```markdown
将这个条件式的每个分支放进一个subclass 内的覆写函数中，然后将原始函数声明为抽象函数（abstract method）。
```
```java
//原代码
public class Employee {
    private int mType;
    static final int salary=500;
    static final int commission=500;
    static final int bonus=1000;

    static final int ENGINEER=0;
    static final int SALESMAN=1;
    static final int MANAGER=2;

    public Employee(int type) {
        this.mType=type;
    }

    int payAmout(){
        switch (mType) {
            case ENGINEER:
                return salary;
            case SALESMAN:
                return salary+commission;
            case MANAGER:
                return salary+bonus;
            default:
                throw new RuntimeException();
        }
    }
}
```
```java
//改造后
public class Employee {
    static final int salary=500;
    static final int commission=500;
    static final int bonus=1000;

    EmployeeType mEmployeeType;

    public void setType(EmployeeType employeeType){
        this.mEmployeeType=employeeType;
    }
    int payAmout(){
        return mEmployeeType.payAmout();
    }
}

public abstract class EmployeeType {
    abstract int payAmout();
}

public class Engineer extends EmployeeType{
    int payAmout() {
        return Employee.salary;
    }
}

public class Manager extends EmployeeType{
    int payAmout() {
        return Employee.salary+Employee.bonus;
    }
}

public class Main {
    public static void main(String[] args) {
        Manager manager=new Manager();
        Salesman salesman=new Salesman();
        Engineer engineer=new Engineer();

        Employee employee=new Employee();

        employee.setType(manager);
        System.out.println("manager工资为:"+employee.payAmout());

        employee.setType(salesman);
        System.out.println("salesman工资为:"+employee.payAmout());

        employee.setType(engineer);
        System.out.println("engineer工资为:"+employee.payAmout());
    }
}
```

#### 尽量少使用else, else if
```markdown
可以使用 if 或者 function 替代。
```
```java
//原代码
if (TimerCategoryEnum.HOLIDAY.getCategory().equals(category)) {
    return saveHolidayLeaveNowTimers(pid, resId, resType, bizType, timeZoneId, uid);
} else if (TimerCategoryEnum.HOLIDAY_SAT.getCategory().equals(category)) {
    return saveHolidaySatNowTimers(pid, resId, resType, bizType, timeZoneId, uid);
} else {
    throw new IllegalParamException("category error");
}
```
```java
//改造后
if (TimerCategoryEnum.HOLIDAY.getCategory().equals(category)) {
    return saveHolidayLeaveNowTimers(pid, resId, resType, bizType, timeZoneId, uid);
}
if (TimerCategoryEnum.HOLIDAY_SAT.getCategory().equals(category)) {
    return saveHolidaySatNowTimers(pid, resId, resType, bizType, timeZoneId, uid);
}
throw new IllegalParamException("category error");
```

### 一次性完成变量的初始化
#### 尽可能的一次性完成变量的初始化，避免变量的声明和赋值分离
```markdown
如果变量的声明和赋值分离，那么就会造成初始化与业务处理混在在一起
```
异常处理demo
```java
//原代码
InputStream is = null;
try {
    is = new FileInputStream(...);
    ...
} catch (IOException e) {
    ...
} finally {
    if (is != null) {
        is.close();
    }
}
```
```java
//改造后
try (InputStream is = new FileInputStream(...)) {
    ...
}
```
集合初始化demo
```java
//原代码
List<String> strings = new ArrayList<>();
strings.add("a);
strings.add("b);
```
```java
//改造后
List<String> strings = ImmutableList.of(
    "a",
    "b"
);
```

### 学会封装
```markdown
面向对象有一个特性是封装: 数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。
但是现在看到满屏的 @Setter, @Data，很明显你的代码正在将一些没有必要暴露的细节统统暴露了。
因此我们要慎重使用@Setter，@Data
```
#### 创建一个对象
```java
//错误示范1
Book book = new Book();
book.setBookId(bookId);
book.setTitle(title);
book.setIntroduction(introduction);
```
```java
//错误示范2
@Getter
@Setter
class Book {
    private BookId bookId;
    private String title;
    private String introduction;
}
```
```java
//正确示范
Book book = new Book(bookId, title, introduction);
```
```java
//火车残骸
String name = book.getAuthor().getName();
```
```java
//改造火车残骸
class Book {
  ...
    public String getAuthorName() {
        return this.author.getName();
    }
  ...
}
String name = book.getAuthorName();
```

### 长参数列表
#### 将参数列表封装成对象
```markdown
人脑能够掌握的内容有限，一旦参数列表变得很长，作为普通人，我们就很难对这些内容进行把控了。
```

#### 区分变与不变
```java
//原代码
public void getChapters(final long bookId, final HttpClient httpClient) {
    HttpUriRequest request = createChapterRequest(bookId);
    HttpResponse response = httpClient.execute(request);
}
```
```java
//改造后
public void getChapters(final long bookId) {
    HttpUriRequest request = createChapterRequest(bookId);
    HttpResponse response = this.httpClient.execute(request);
}
```

#### 使用ThreadLocal case
```java
public class HolidayPeriodMapContext implements AutoCloseable {

    private static final ThreadLocal<HolidayPeriodMapBO> CTX = new ThreadLocal<>();


    public HolidayPeriodMapContext(HolidayPeriodMapBO holiday) {
        CTX.set(holiday);
    }

    public static HolidayPeriodMapBO currentHolidayPeriodMap() {
        return CTX.get();
    }

    @Override
    public void close() {
        CTX.remove();
    }
}

try (HolidayPeriodMapContext holidayCtx = new HolidayPeriodMapContext(holiday)) {
    ..............................
}
```

#### 告别标记
```java
//原代码
public void doSth(final boolean flag) {
    ...
    if (flag) {

    }

    if (!flag) {

    }
}
```
```java
//改造后
public void doSth1() {
    ...
}

public void doSth2() {
    ...
}
```


### 如何处理null
```java
//原代码
public Country getBirthCountry() {
    return this.getBirthPlace() // 获取出生地
        .getCity()      // 获取城市
        .getProvince()  // 获取省份
        .getCountry();  // 获取国家
}
```
```java
//为了避免空指针
public Country getBirthCountry() {
    Place place = this.birthPlace;
    if (place != null) {
        City city = place.getCity();
        if (city != null) {
            Province province = city.getProvince();
            if (province != null) {
                return province.getCountry();
            }
        }
    }
    return null;
}
```
怎么简单的处理null？
#### Optional
```markdown
如果有一个非空对象，可以用 of() 将它包装成一个 Optional 对象；

如果要表示空，可以返回一个 empty()；

如果有一个从别处传来的对象，你不知道它是不是空，可以用 ofNullable()。
```
```java
//改造后
Optional.of("Hello"); // 创建一个Optional对象，其中包含了"Hello"字符串
Optional.empty(); // 创建了一个表示空对象的Optional对象。
Optional.ofNullable(instance); // 创建了一个Optional对象，不知instance是否为空。
```

### 设计模式
参考 1设计模式 篇章

### 函数式编程
参考 Java8 函数式编程

* [返回主页](../home.md)