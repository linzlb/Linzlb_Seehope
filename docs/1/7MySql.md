---
prev: 6Spring
next: 8SpringBoot
---
* [返回主页](../home.md)
# 7MySql
## 数据库范式
::: tip 1NF 无重复列
属性不可再分（就是字段只能是一个值）
:::

::: tip 2NF 有唯一键
在1NF的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键 
:::

::: tip 3NF 数据不冗余
在2NF基础上，非主键要依赖主键，不能依赖其他 
:::

## 存储引擎
![](../../picture/1/7存储引擎.png)

## 基础架构
![](../../picture/1/7基础架构.png)

## InnoDB 存储引擎的锁
+ 表锁
+ 行锁
    + Record lock
        + 记录锁，单个行记录上的锁
    + Gap lock
        + 间隙锁，锁定一个范围，不包括记录本身
    + Next-key lock
        + record+gap 临键锁，锁定一个范围，包含记录本身

## InnoDB行格式
![](../../picture/1/7InnoDB行格式.png)

## InnoDB的数据页结构
![](../../picture/1/7InnoDB的数据页结构.png)

## InnoDB的表空间
![](../../picture/1/7InnoDB的表空间.png)

## 索引
### 定义
>用于快速查询和检索数据的数据结构

### 优点
+ 使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）
+ 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性

### 缺点
+ 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。
+ 索引需要使用物理文件存储，也会耗费一定空间

### 数据结构
![](../../picture/1/7索引数据结构.png)

### 存储结构
::: tip 页
各数据页组成双向链表 , 每页数据是单向链表
:::

### 索引分类
![](../../picture/1/7索引分类.png)

### 覆盖索引
> 覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了， 而无需回表查询。

### 索引下沉
索引下推是数据库检索数据过程中为减少回表次数而做的优化。eg.
```sql
select * from usertest where name like 'a%' and age = 10;
```
::: tip Mysql5.6之前的执行流程
根据最左前缀原则，执行name like 'a%'可以快速检索出id的值为1，5。
然后根据id的值进行回表操作，再次进行过滤age=10的数据
:::
::: tip Mysql5.6以后
在索引里面直接过滤age=10的数据，因为复合索引里面也存了age的数据，这样明明可以减少回表1次
这就是索引下沉
:::

### MYSQL索引底层结构为什么使用B+树?
> 因为B+树可以让索引结构最胖最矮，对于树的每一层节点，实际上对应着一次磁盘IO

### 索引失效情况
![](../../picture/1/7索引失效情况.png)

## 日志
### 二进制日志
::: tip  binlog日志
逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层<br>
会记录所有涉及更新数据的逻辑操作，并且是顺序写。<br>
不管用什么存储引擎，只要发生了表数据更新，都会产生 binlog 日志。
:::

![](../../picture/1/7binlog日志.png)


### 事务日志
#### redo log重做日志
![](../../picture/1/7redolog重做日志.png)

#### undo log回滚日志
![](../../picture/1/7undolog.png)

#### MVCC
![](../../picture/1/7MVCC.png)

#### 二阶段提交
![](../../picture/1/7二阶段提交.png)


## 事务
### 事务特性
::: tip ACID
原子性（Atomicity）<br>
事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用<br><br>
一致性（Consistency）<br>
执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的<br><br>
隔离性（Isolation）<br>
并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的<br><br>
持久性（Durability）<br>
一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响
:::

### 并发事务带来的问题
![](../../picture/1/7并发事务带来的问题.png)

### 事务隔离级别
::: tip 事务隔离级别
READ-UNCOMMITTED(读取未提交)<br>
最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。<br><br>
READ-COMMITTED(读取已提交）<br>
允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。<br><br>
REPEATABLE-READ(可重复读) 默认隔离级别<br>
对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。<br><br>
SERIALIZABLE(可串行化)<br>
最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。
:::

### 事务原理
::: warning 要解决的场景问题
未提交事务，写入后崩溃<br>
已提交事务，写入前崩溃
::: 
::: tip 解决方式
崩溃恢复机制<br>
需要记录日志，即redo log，也叫Commit Logging”（提交日志）
:::

#### 一致性的保证依赖
> 一致性依赖原子性和持久性和隔离性

##### 原子性和持久性的保证
![](../../picture/1/7原子性和持久性的保证.png)

##### 隔离性保证
![](../../picture/1/7隔离性保证.png)

###### MVCC
![](../../picture/1/7MVCC2.png)

## 优化
![](../../picture/1/7优化.png)

## 读写分离&分库分表
### 读写分离
![](../../picture/1/7读写分离.png)
#### 主从复制原理
![](../../picture/1/7主从复制的原理.png)
### 分库分表
![](../../picture/1/7分库分表.png)


* [返回主页](../home.md)