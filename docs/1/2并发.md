---
prev: 1集合
next: 3JVM
---
* [返回主页](../home.md)
# 2并发
## Java内存区域
![](../../picture/1/2java内存区域.png)

## 多线程
![](../../picture/1/2多线程.png)

## 关键字&重要类
### sleep/wait 暂停线程比较
```text
sleep()
    没释放锁，占用CPU
    一般用于缓存
wait()
    释放了锁，不占用CPU，被唤醒后要做上下文切换
    一般用于线程间通信/交互
```
### synchronized
![](../../picture/1/2synchronized.png)

### volatile
![](../../picture/1/2volatile.png)

### ThreadLocal
#### 目的
```text
让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据
```
#### 源码实现
![](../../picture/1/2ThreadLocal源码实现.png)

#### 内存泄漏问题
```text
由上面源码实现ThreadLocalMap可以看到key 为 ThreadLocal 的弱引用,而 value 是强引用
如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。
这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。
假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。
最常用的解决方法就是一定要强引用ThreadLocal，这样key也会一直使用
```
```java
//如果是需要回收的key和value的情况，使用完手动remove()
public class HolidayPeriodMapContext implements AutoCloseable {

    private static final ThreadLocal<HolidayPeriodMapBO> CTX = new ThreadLocal<>();
    
    public HolidayPeriodMapContext(HolidayPeriodMapBO holiday) {
        CTX.set(holiday);
    }
    public static HolidayPeriodMapBO currentHolidayPeriodMap() {
        return CTX.get();
    }

    @Override
    public void close() {
        CTX.remove();
    }
}

try (HolidayPeriodMapContext holidayCtx = new HolidayPeriodMapContext(holiday)) {
    ..............................
}
```

#### 场景
```text
用户全局token，原理：自定义拦截器，获取用户信息放ThreadLocal中
获取reqId并处理
```

#### InheritableThreadLocal
##### 目的
> 如果希望当前线程的ThreadLocal能够被子线程使用
##### 实现
Thread类的init方法中，会判断是否将可继承的ThreadLocal变量传递到子线程
```java
if (inheritThreadLocals && parent.inheritableThreadLocals != null)
    this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
```

## Unsafe类
![](../../picture/1/2unsafe.png)

## JUC

* [返回主页](../home.md)